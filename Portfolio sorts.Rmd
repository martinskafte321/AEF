---
title: 'AEF - assignment #1'
author: "Martin Andersen"
date: "6/3/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


### Loading packages:
```{r echo=false}
library(RSQLite)
library(dbplyr)
library(tidyverse)
library(lubridate)
library(sandwich)
library(lmtest)
library(scales)
library(slider)
library(furrr)

setwd('C:/Users/Marti/OneDrive - University of Copenhagen/KU/2. semester/Advanced Empirical Finance/AEF')
```

# ******************************************
# 4.1 Data preparation
# ******************************************

```{r cars}
tidy_finance <- dbConnect(SQLite(), "data/tidy_finance1.sqlite",
                          extended_types = TRUE)

crsp_monthly <- tbl(tidy_finance, "crsp_monthly") %>%
  collect() %>%
  mutate(month = as.Date(as.POSIXct.Date(month)))

factors_ff_monthly <- tbl(tidy_finance, "factors_ff_monthly") %>%
  collect() %>%
  mutate(month = as.Date(as.POSIXct.Date(month)))

beta <- tbl(tidy_finance, "beta") %>%
  collect() %>%
  mutate(month = as.Date(as.POSIXct.Date(month)))

crsp_monthly <- crsp_monthly %>%
  left_join(factors_ff_monthly, by = "month") %>%
  select(permno, month, ret_excess, mkt_excess, mktcap_lag)
crsp_monthly

dbListTables(tidy_finance) # check the database
```

# ******************************************
# 4.2 Sorting by market beta
# ******************************************

```{r}
beta_lag <- beta %>%
  mutate(month = month %m+% months(1)) %>%
  select(permno, month, beta_lag = beta_daily) %>%
  drop_na()

data_for_sorts <- crsp_monthly %>%
  inner_join(beta_lag, by = c("permno", "month"))

```

2. Create portfolio sorts based on the lagged beta. More specifically, each month you compute the breakpoint as the median lag beta, then you compute the returns of a portfolio that invests only in the stocks that had a higher beta than the breakpoint and a portfolio that invests only in the stocks that had a lower beta than the breakpoints. The portfolio weights can either be equal or value weighted.

The first step to conduct portfolio sorts is to calculate periodic breakpoints that you can use to group the stocks into portfolios.
```{r}
beta_portfolios <- data_for_sorts %>%
  group_by(month) %>%
  mutate(
    breakpoint = median(beta_lag),
    portfolio = case_when(
      beta_lag <= breakpoint ~ "low",
      beta_lag > breakpoint ~ "high"
    )
  ) %>%
  group_by(month, portfolio) %>%
  summarize(ret = weighted.mean(ret_excess, mktcap_lag), .groups = "drop")
```

# ******************************************
# 4.3 Performance evaluation
# ******************************************

The following figure shows the monthly excess returns of the two portfolios.
```{r}
beta_portfolios %>%
  ggplot(aes(x = month, y = ret, fill = portfolio)) +
  geom_col() +
  facet_wrap(~portfolio, ncol = 1) +
  scale_y_continuous(labels = percent) +
  labs(
    x = NULL, y = NULL,
    title = "Monthly beta portfolio excess returns using median as breakpoint"
  ) +
  theme(legend.position = "none")
```

We can construct a long-short strategy based on the two portfolios: buy the high-beta portfolio and, at the same time, short the low-beta portfolio.
```{r}
beta_longshort <- beta_portfolios %>%
  pivot_wider(month, names_from = portfolio, values_from = ret) %>%
  mutate(long_short = high - low)  %>%
  left_join(
    factors_ff_monthly %>% mutate(month = as.POSIXct.Date(month)), by = "month")
```

We compute the average return and the corresponding standard error to test whether the long-short portfolio yields on average positive or negative excess returns. To implement this test, we compute the average return via lm() and then employ the coeftest function.
```{r}
model_fit <- lm(long_short ~ 1, data = beta_longshort)
coeftest(model_fit, vcov = NeweyWest, lag = 6)
```


# ******************************************
# 4.4 Functional programming for portfolio sorts
# ******************************************

We need to create a function that is able to sort stocks into a number of portfolios. We use quantile() to compute breakpoints for n_portfolios. Then, we assign portfolios to stocks using the findInterval() function. The output of the following function is a new column that contains the number of the portfolio to which a stock belongs.
```{r}
assign_portfolio <- function(data, var, n_portfolios) {
  breakpoints <- data %>%
    summarize(breakpoint = quantile({{ var }},
                                    probs = seq(0, 1, length.out = n_portfolios + 1),
                                    na.rm = TRUE
    )) %>%
    pull(breakpoint) %>%
    as.numeric()
  
  data %>%
    mutate(portfolio = findInterval({{ var }},
                                    breakpoints,
                                    all.inside = TRUE
    )) %>%
    pull(portfolio)
}
```
We can use the above function to sort stocks into ten portfolios each month using lagged betas and compute value-weighted returns for each portfolio. Note that we transform the portfolio column to a factor variable because it provides more convenience for the figure construction below.

```{r}
beta_portfolios <- data_for_sorts %>%
  group_by(month) %>%
  mutate(
    portfolio = assign_portfolio(
      data = cur_data(),
      var = beta_lag,
      n_portfolios = 10
    ),
    portfolio = as.factor(portfolio)
  ) %>%
  group_by(portfolio, month) %>%
  summarize(ret = weighted.mean(ret_excess, mktcap_lag), .groups = "drop")
```